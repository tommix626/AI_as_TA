import json

def _parse_cascade_raw_schema(generated_schema):
    """
    Further manipulate the dict converted from raw json string input.
    Attempts to parse the LLM generated schema into a structured format.
    If parsing fails, returns None.

    :param generated_schema: a json conversion of component descriptions generated by the LLM chain
    :return: a list of component dicts (name, id, inputs, outputs) or None if parsing fails
    """
    try:
        components = []
        for component in generated_schema:
            component_name, component_id = component["name"].split('@')
            comp_details = {
                "name": component_name,  # Name used for finding the class
                "id": component["name"],  # Unique ID, in the form ClassName_{4 char id}
                "inputs": {},
                "outputs": {}
            }
            for input_param in component.get("inputs", []):
                comp_details["inputs"][input_param["parameter"]] = input_param.get("content", "")
            for output_param in component.get("outputs", []):
                comp_details["outputs"][output_param["parameter"]] = output_param.get("content", "")
            components.append(comp_details)
        return components
    except Exception as e:
        # Log the error or print a message if desired
        print(f"Error parsing LLM generated schema: {e}")
        return None

def _convert_json_to_dict(json_string):
    try:
        return json.loads(json_string)
    except json.JSONDecodeError as e:
        print(f"Error decoding JSON: {e.msg}")
        return None